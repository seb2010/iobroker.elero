/*
Support for Elero electrical drives.
For more details about this platform, please refer to the documentation at
https://home-assistant.io/components/elero/
*/
//#todo: import logging

//#todo: import homeassistant.helpers.config_validation as cv
//#todo: import serial
//#todo: import voluptuous as vol
//#todo: from homeassistant.const import EVENT_HOMEASSISTANT_STOP
//#todo: from serial.tools import list_ports

// Python libraries/modules that you would normally install for your component.
var serialport = require("serialport"); 
var SerialPort = serialport.SerialPort; 

// The domain of your component. Equal to the filename of your component.
DOMAIN = 'elero';

// The connected Transmitter devices.
ELERO_TRANSMITTERS = None;

// Configs to the serial connection.
CONF_TRANSMITTERS = 'transmitters';
CONF_TRANSMITTER_SERIAL_NUMBER = 'serial_number';
CONF_BAUDRATE = 'baudrate';
CONF_BYTESIZE = 'bytesize';
CONF_PARITY = 'parity';
CONF_STOPBITS = 'stopbits';

// Default serial info
DEFAULT_BRAND = 'elero';
DEFAULT_PRODUCT = 'Transmitter Stick';

// Default serial connection details.
DEFAULT_BAUDRATE = 38400;
DEFAULT_BYTESIZE = 8;
DEFAULT_PARITY = "none";
DEFAULT_STOPBITS = 1;

// values to bit shift.
HEX_255 = 0xFF;
BIT_8 = 8;

// Header for all command.
BYTE_HEADER = 0xAA;
// command lengths
BYTE_LENGTH_2 = 0x02;
BYTE_LENGTH_4 = 0x04;
BYTE_LENGTH_5 = 0x05;

// Wich channels are learned.
COMMAND_CHECK = 0x4A;
// required response lenth.
RESPONSE_LENGTH_CHECK = 6;
// The Playload will be send to all channel with bit set.
COMMAND_SEND = 0x4C;
// required response lenth.
RESPONSE_LENGTH_SEND = 7;
// Get the status or position of the channel.
COMMAND_INFO = 0x4E;
// Required response lenth.
RESPONSE_LENGTH_INFO = 7;
// for Serial error handling
NO_SERIAL_RESPONSE = b'';

// Playloads to send.
PAYLOAD_STOP = 0x10;
PAYLOAD_STOP_TEXT = "stop";
PAYLOAD_UP = 0x20;
PAYLOAD_UP_TEXT = "up";
PAYLOAD_VENTILATION_POS_TILTING = 0x24;
PAYLOAD_VENTILATION_POS_TILTING_TEXT = "ventilation position/tilting";
PAYLOAD_DOWN = 0x40;
PAYLOAD_DOWN_TEXT = "down";
PAYLOAD_INTERMEDIATE_POS = 0x44;
PAYLOAD_INTERMEDIATE_POS_TEXT = "intermediate position/tilting";

// Info to receive response.
INFO_UNKNOWN = "unknown response";
INFO_NO_INFORMATION = "no information";
INFO_TOP_POSITION_STOP = "top position stop";
INFO_BOTTOM_POSITION_STOP = "bottom position stop";
INFO_INTERMEDIATE_POSITION_STOP = "intermediate position stop";
INFO_TILT_VENTILATION_POS_STOP = "tilt ventilation position stop";
INFO_BLOCKING = "blocking";
INFO_OVERHEATED = "overheated";
INFO_TIMEOUT = "timeout";
INFO_START_TO_MOVE_UP = "start to move up";
INFO_START_TO_MOVE_DOWN = "start to move down";
INFO_MOVING_UP = "moving up";
INFO_MOVING_DOWN = "moving down";
INFO_STOPPED_IN_UNDEFINED_POSITION = "stopped in undefined position";
INFO_TOP_POS_STOP_WICH_TILT_POS = "top position stop wich is tilt position";
INFO_BOTTOM_POS_STOP_WICH_INT_POS = "bottom position stop wich is intermediate position";
INFO_SWITCHING_DEVICE_SWITCHED_OFF = "switching device switched off";
INFO_SWITCHING_DEVICE_SWITCHED_ON = "switching device switched on";

INFO = {0x00: INFO_NO_INFORMATION,
        0x01: INFO_TOP_POSITION_STOP,
        0x02: INFO_BOTTOM_POSITION_STOP,
        0x03: INFO_INTERMEDIATE_POSITION_STOP,
        0x04: INFO_TILT_VENTILATION_POS_STOP,
        0x05: INFO_BLOCKING,
        0x06: INFO_OVERHEATED,
        0x07: INFO_TIMEOUT,
        0x08: INFO_START_TO_MOVE_UP,
        0x09: INFO_START_TO_MOVE_DOWN,
        0x0A: INFO_MOVING_UP,
        0x0B: INFO_MOVING_DOWN,
        0x0D: INFO_STOPPED_IN_UNDEFINED_POSITION,
        0x0E: INFO_TOP_POS_STOP_WICH_TILT_POS,
        0x0F: INFO_BOTTOM_POS_STOP_WICH_INT_POS,
        0x10: INFO_SWITCHING_DEVICE_SWITCHED_OFF,
        0x11: INFO_SWITCHING_DEVICE_SWITCHED_ON,
        };

/*
ELERO_TRANSMITTER_SCHEMA = vol.Schema({
    vol.Optional(CONF_TRANSMITTER_SERIAL_NUMBER): str,
    vol.Optional(CONF_BAUDRATE, default=DEFAULT_BAUDRATE): cv.positive_int,
    vol.Optional(CONF_BYTESIZE, default=DEFAULT_BYTESIZE): cv.positive_int,
    vol.Optional(CONF_PARITY, default=DEFAULT_PARITY): str,
    vol.Optional(CONF_STOPBITS, default=DEFAULT_STOPBITS): cv.positive_int,
});*/

class EleroTransmitters{
    //Container for the Elero Centero USB Transmitter Sticks.

    	constructor(config){
		//Initialize the usb sticks.
		this.config = config;
		this.transmitters = {};
	}
	
    	discover(){
		//Discover the connected Elero Transmitter Sticks.
		//#todo: change to serialport-function references
		this.log.debug('Discovering Transmitters...');
		serialport.list(function (err, ports) {
			ports.forEach(function(port) {
				this.log.debug(port.path);
				this.log.debug(port.serialNumber);
				this.log.debug(port.manufacturer);
				if(DEFAULT_BRAND in port.manufacturer and DEFAULT_PRODUCT in port.product){
					this.log.debug("Elero - an Elero Transmitter Stick is found on port: '"+port.path+"'"+" with serial number: '"+port.serialNumber+"'");

					if(port.serialNumber in this.config){
					    baudrate = this.config[port.serial_number].get(CONF_BAUDRATE);
					    bytesize = this.config[port.serial_number].get(CONF_BYTESIZE);
					    parity = this.config[port.serial_number].get(CONF_PARITY);
					    stopbits = this.config[port.serial_number].get(CONF_STOPBITS);
					}else{
					    baudrate = DEFAULT_BAUDRATE;
					    bytesize = DEFAULT_BYTESIZE;
					    parity = DEFAULT_PARITY;
					    stopbits = DEFAULT_STOPBITS;
					}
					
					this.log.debug("Initializing Transmitter '"+port.serialNumber+"' at Port: '"+port.name+"'");
					elero_transmitter = EleroTransmitter(port, baudrate, bytesize, parity, stopbits);

					if(elero_transmitter.get_transmitter_state()){
						this.log.debug("Transmitter '"+port.serialNumber+"' initialized");
						 if(port.serialNumber not in this.transmitters){
							this.transmitters[port.serialNumber] = elero_transmitter;
						}else{
							this.log.debug("Elero - '"+port.serialNumber+"' transmitter is already added!");
						}
					}
				}
			}
		});
	}
	
	get_first_transmitter(){
		//returns the first transmitter
		this.transmitter.foreach(function(t) {
			if(t.get_transmitter_state()){
				return t;
			}
		});	
	}
			
	get_transmitter(serialNumber){
		//Return the given transmitter.
		if(serialNumber in this.transmitters){
		    return this.transmitters[serialNumber];
		}else{
		    this.log.debug("Elero - the transmitter '"+serialNumber+"' is not exist!");
		    return None;
		}
	}
	
    	close_transmitters(){
        //Close the serial connection of the transmitters.
		this.transmitter.foreach(function(t) {
			t.close();
		});
	}
}

class EleroTransmitter{
    //Representation of an Elero Centero USB Transmitter Stick.

    	constructor(serial_port, baudrate, bytesize, parity, stopbits){
		//Initialization of a elero transmitter.
		this.serial_port = serial_port;
		this._serial_number =.serial_port.serialNumber;
		this._port = serial_port.path;
		this._baudrate = baudrate;
		this._bytesize = bytesize;
		this._parity = parity;
		this._stopbits = stopbits;
		//setup the serial connection to the transmitter
		this._serial = None;
		this._init_serial();
		//get the learned channels from the transmitter
		this._learned_channels = {};
		if(this._serial){
		    this.check();
		}
	}

    	_init_serial(){
		//Init the serial port to the transmitter.
		//#todo: richtig Ã¼ber serialport initialisieren
		try{
			this._serial = new serialport(this._port, {
				    baudRate: this._baudrate,
				    dataBits: this._bytesize,
				    parity: this._parity,
				    stopBits: this._stopbits
			});
			this._serial.open();
        	}
		catch(exc){
            		this.log.debug("Elero - unable to open serial port for '"+this._serial_number+"' to the Transmitter Stick: "+exc.toString());
		}
	}
	
    	log_out_serial_port_details(){
		//Log out the details of the serial connection.
		/#todo: serialport details 
		details = this.serial_port.toString();
		this.log.debug("Elero - transmitter stick on port '"+this._port+"' details: '"+details+"'."
			      .format(this._port, details));
	}
	
   	close_serial(){
		//Close the serial connection of the transmitter.
		this._serial.close();
	}
	
    	get_transmitter_state(){
		//The transmitter is usable or not.
		return this._serial;
	}
	
    	get_serial_number(){
		//Return the ID of the transmitter.
		return this._serial_number
	}
	
    	_get_check_command(){
		//Create a hex list to Check command.
		int_list = [BYTE_HEADER, BYTE_LENGTH_2,
			    COMMAND_CHECK];
		return int_list;
	}
	
    	check(){
		//Wich channels are learned.
		//Should be received an answer "Easy Confirm" with in 1 second.
		//
		this._send_command(this._get_check_command(), 0);
		ser_resp = this._read_response(RESPONSE_LENGTH_CHECK, 0);
		if(ser_resp){
		    resp = this._parse_response(ser_resp, 0);
		    this._learned_channels = Object.keys(resp['chs']);
		    this.log.debug("The taught channels on the '"+this._serial_number+"' transmitter are '"+this._learned_channels.join(" ")+"'.");
		}
	}
	
	get_learned_channels(){
		//Return all learned Channels
		return this._learned_channels;
	}
	
    	set_channel(channel, obj){
		//Set the channel if it is learned.
		if(channel in this._learned_channels){
		    this._learned_channels[channel] = obj
		    return True;
		}else{
		    this.log.debug("The '"+channel+"' channel is not taught to the "
				  "'"+this._serial_number+"' transmitter.");
		    return False;
		}
	}
	
   	 _get_info_command(channel){}
		//Create a hex list to the Info command.
		int_list = [BYTE_HEADER, BYTE_LENGTH_4,
			    COMMAND_INFO,
			    this._set_upper_channel_bits(channel),
			    this._set_lower_channel_bits(channel)];
		return int_list;
	}
	
    	info(channel){
		//Return the current state of the cover.
		//Should be received an answer "Easy Act" with in 4 seconds.
		//
		this._send_command(this._get_info_command(channel), channel);
	}
	
    	_get_up_command(channel){
		//Create a hex list to Open command.
		int_list = [BYTE_HEADER, BYTE_LENGTH_5,
			    COMMAND_SEND,
			    this._set_upper_channel_bits(channel),
			    this._set_lower_channel_bits(channel),
			    PAYLOAD_UP];
		return int_list;
	}
	
    	up(channel){
		//Open the cover.
		//Should be received an answer "Easy Act" with in 4 seconds.
		//
		this._send_command(this._get_up_command(channel), channel);
	}
	
    	_get_down_command(channel){
		//Create a hex list to Close command.
		int_list = [BYTE_HEADER, BYTE_LENGTH_5,
			    COMMAND_SEND,
			    this._set_upper_channel_bits(channel),
			    this._set_lower_channel_bits(channel),
			    PAYLOAD_DOWN];
		return int_list;
	}
	
    	down(channel){
		//Close the cover.
		//Should be received an answer "Easy Act" with in 4 seconds.
		//
		this._send_command(this._get_down_command(channel), channel);
	}
	
    	_get_stop_command(channel){
		//Create a hex list to the Stop command.
		int_list = [BYTE_HEADER, BYTE_LENGTH_5,
			    COMMAND_SEND,
			    this._set_upper_channel_bits(channel),
			    this._set_lower_channel_bits(channel),
			    PAYLOAD_STOP];
		return int_list;
	}
	
    	stop(channel){
		//Stop the cover.
		//Should be received an answer "Easy Act" with in 4 seconds.
		//
		this._send_command(this._get_stop_command(channel), channel);
	}
	
    	_get_intermediate_command(channel){
		//Create a hex list to the intermediate command.
		int_list = [BYTE_HEADER, BYTE_LENGTH_5,
			    COMMAND_SEND,
			    this._set_upper_channel_bits(channel),
			    this._set_lower_channel_bits(channel),
			    PAYLOAD_INTERMEDIATE_POS];
		return int_list;
	}
	
    	intermediate(channel){
		//Set the cover in intermediate position.
		//Should be received an answer "Easy Act" with in 4 seconds.
		//
		this._send_command(this._get_intermediate_command(channel), channel);
	}
	
    	_get_ventilation_tilting_command(channel){
		//Create a hex list to the ventilation command.
		int_list = [BYTE_HEADER, BYTE_LENGTH_5,
			    COMMAND_SEND,
			    this._set_upper_channel_bits(channel),
			    this._set_lower_channel_bits(channel),
			    PAYLOAD_VENTILATION_POS_TILTING];
		return int_list;
	}

    	ventilation_tilting(channel){
		//Set the cover in ventilation position.
		//Should be received an answer "Easy Act" with in 4 seconds.
		//
		this._send_command(this._get_ventilation_tilting_command(channel),
				   channel);
	}
	
    	_read_response(resp_length, channel){
		//Get the serial data from the serial port.
			//'todo: serialport response reading
		if(not this._serial.isOpen()){
		    this._serial.open();
			}
		ser_resp = this._serial.read(resp_length);
		this.log.debug("Elero - transmitter: '"+this._serial_number+"' ch: '"+channel+"' serial response: '"+ser_resp+"'.");
		return ser_resp;
	}
	
    	_parse_response(ser_resp, channel){
		//Parse the serial data as a response
			//#todo: serialport response reading
		response = {'bytes': None,
			    'header': None,
			    'length': None,
			    'command': None,
			    'ch_h': None,
			    'ch_l': None,
			    'chs': set(),
			    'status': None,
			    'cs': None,
			    };

		response['bytes'] = ser_resp;
		//No response or serial data
		if(not ser_resp){
		    response['status'] = INFO_NO_INFORMATION;
		    return;
		}
		resp_length = len(ser_resp);
		//Common parts
		response['header'] = ser_resp[0];
		response['length'] = ser_resp[1];
		response['command'] = ser_resp[2];
		response['ch_h'] = this._get_upper_channel_bits(ser_resp[3]);
		response['ch_l'] = this._get_lower_channel_bits(ser_resp[4]);
		response['chs'] = set(response['ch_h'] + response['ch_l']);
		//Easy Confirmed (the answer on Easy Check)
		if(resp_length == RESPONSE_LENGTH_CHECK){
		    response['cs'] = ser_resp[5];
		//Easy Ack (the answer on Easy Info)
		}else if(resp_length == RESPONSE_LENGTH_SEND){
		   	 if(ser_resp[5] in INFO){
				response['status'] = INFO[ser_resp[5]];
		   	 }else{
				response['status'] = INFO_UNKNOWN;
				this.log.debug("Elero - transmitter: '"+this._serial_number+"' ch: '"+channel+"' status is unknown: '"+ser_resp[5]+"'.");
			}
		    response['cs'] = ser_resp[6];
		}else{
		    this.log.debug("Elero - transmitter: '"+this._serial_number+"' ch: '"+channel+"' unknown response: '"+ser_resp+"'.");
		    response['status'] = INFO_UNKNOWN;
		}
		return response;
	}
	
    	get_response(resp_length, channel){
		//Read the response form the device.
		ser_resp = this._read_response(resp_length, channel);
		resp = this._parse_response(ser_resp, channel);
		//no meaningful response
		if(resp['status'] == INFO_NO_INFORMATION){
		    return;
		}
		//reply to the appropriate channel
		if(len(resp['chs']) == 1){
			ch = resp['chs'].pop()
			//call back the channel with its result
			if(ch in this._learned_channels){
				this._learned_channels[ch](resp);
			}else{
				this.log.debug("Elero - no matched channel '"+ch+"'.");
			}
		}else{
            		this.log.debug("Elero - more than one channel in the response: '"+resp+"'.");
		}
	}
	
    	_send_command(int_list, channel){
		//Write out a command to the serial port.
		int_list.append(this._calculate_checksum(int_list));
		bytes_data = this._create_serial_data(int_list);
		this.log.debug("Elero - transmitter: '"+this._serial_number*"' ch: '"+channel+"' serial command: '"+bytes_data+"'.";
		if(not this._serial.isOpen()){
		    this._serial.open();
		}
		this._serial.write(bytes_data);
	}
	
	_calculate_checksum(args){
		//Calculate checksum.
		//All the sum of all bytes (Header to CS) must be 0x00.
		//
		return (256 - sum(args)) % 256;
	}

    	_create_serial_data(int_list){
		//Convert integers to bytes for serial communication.
		bytes_data = bytes(int_list);
		return bytes_data;
	}
	
    	_set_upper_channel_bits(channel){
		//Set upper channel bits, for channel 9 to 15.
		res = (1 << (channel-1)) >> BIT_8;
		return res;
	}
	
    	_set_lower_channel_bits(channel){
		//Set lower channel bits, for channel 1 to 8.
		res = (1 << (channel-1)) & HEX_255;
		return res;
	}
	
    	_get_upper_channel_bits(byt){
		//The set channel numbers from 9 to 15.
		channels = [];
		for each (var i in range(0, 8)){
		    if((byt >> i) & 1 == 1){
			ch = i + 9;
			channels.append(ch);
				}
			}
        	return tuple(channels);
	}
	
    	_get_lower_channel_bits(byt){
		//The set channel numbers from 1 to 8.
		channels = [];
		for each (var i in range(0, 8)){
		    	if((byt >> i) & 1 == 1){
				ch = i + 1;
				channels.append(ch);
			}
		}
		return tuple(channels);
	}
}
